## Standard install via command-line
```bash
# Configure the project and generate a native build system:
  # Must re-run this command whenever any CMakeLists.txt file has been changed.
  cmake -S ./ -B build/
# Compile and build the project:
  # rebuild only files that are modified since the last build
  cmake --build build/
  # or rebuild everything from scracth
  cmake --build build/ --clean-first
  # to see verbose output, do:
  cmake --build build/ --verbose
# Run program:
  ./build/app/shell-app
# Clean
  cmake --build build/ --target clean
# Clean and start over:
  rm -rf build/
```

## Corrections

* There was an uninitalised bolean variable in the `/app/main.cpp` file
* There was a raw pointer to a vector allocated in the `Read()` function of the file `/app.AnalogSensor.cpp` which was never deleted, hence lead to a memory leakage.
* The corrections have been made in the respective files
* To view the outputs generated by valgrind go to the valgrinf directory.
```
cd valgrind-output/non-static
```

## Generating and Storing Valgrind Output

Use the following command to generate and store valgrind output
```
vagrind -leak--check==full ./build/app/shell-app > /valgrind-output/non-static/valgrind-output-corrected.txt
```

## Extra Credit Questions 

* What happens when the executable is linked statically?  Does Valgrind still detect those same bugs?
  * First we need to understand what does statically linking mean, it means that when the executable is made all the required libraries are pasted in the executable directly when the executable is made. 
  * Now when I used valgrind on statically combined executable it did find the error of uninitialized value, but did not find the memory leak error.
  
* Why this happens?
  * Valgrind relies on code instrumentation to track memory operations. In dynamically linked executables, it can insert its own code into library functions to monitor memory. This is not possible in statically linked executables.
